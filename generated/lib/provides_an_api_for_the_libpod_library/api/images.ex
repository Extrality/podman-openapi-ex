# NOTE: This file is auto generated by OpenAPI Generator 7.19.0-SNAPSHOT (https://openapi-generator.tech).
# Do not edit this file manually.

defmodule ProvidesAnAPIForTheLibpodLibrary.Api.Images do
  @moduledoc """
  API calls for all endpoints tagged `Images`.
  """

  alias ProvidesAnAPIForTheLibpodLibrary.Connection
  import ProvidesAnAPIForTheLibpodLibrary.RequestBuilder

  @doc """
  Create image
  Build an image from the given Dockerfile(s)

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `opts` (keyword): Optional parameters
    - `:dockerfile` (String.t): Path within the build context to the `Dockerfile`. This is ignored if remote is specified and points to an external `Dockerfile`. 
    - `:t` (String.t): A name and optional tag to apply to the image in the `name:tag` format.  If you omit the tag the default latest value is assumed. You can provide several t parameters.
    - `:allplatforms` (boolean()): Instead of building for a set of platforms specified using the platform option, inspect the build's base images, and build for all of the platforms that are available.  Stages that use *scratch* as a starting point can not be inspected, so at least one non-*scratch* stage must be present for detection to work usefully. 
    - `:extrahosts` (String.t): TBD Extra hosts to add to /etc/hosts (As of version 1.xx) 
    - `:remote` (String.t): A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the file’s contents are placed into a file called Dockerfile and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the dockerfile parameter is also specified, there must be a file with the corresponding path inside the tarball. (As of version 1.xx) 
    - `:q` (boolean()): Suppress verbose build output 
    - `:nocache` (boolean()): Do not use the cache when building the image (As of version 1.xx) 
    - `:cachefrom` (String.t): JSON array of images used to build cache resolution (As of version 1.xx) 
    - `:pull` (boolean()): Attempt to pull the image even if an older image exists locally (As of version 1.xx) 
    - `:rm` (boolean()): Remove intermediate containers after a successful build (As of version 1.xx) 
    - `:forcerm` (boolean()): Always remove intermediate containers, even upon failure (As of version 1.xx) 
    - `:memory` (integer()): Memory is the upper limit (in bytes) on how much memory running containers can use (As of version 1.xx) 
    - `:memswap` (integer()): MemorySwap limits the amount of memory and swap together (As of version 1.xx) 
    - `:cpushares` (integer()): CPUShares (relative weight (As of version 1.xx) 
    - `:cpusetcpus` (String.t): CPUSetCPUs in which to allow execution (0-3, 0,1) (As of version 1.xx) 
    - `:cpuperiod` (integer()): CPUPeriod limits the CPU CFS (Completely Fair Scheduler) period (As of version 1.xx) 
    - `:cpuquota` (integer()): CPUQuota limits the CPU CFS (Completely Fair Scheduler) quota (As of version 1.xx) 
    - `:buildargs` (String.t): JSON map of string pairs denoting build-time variables. For example, the build argument `Foo` with the value of `bar` would be encoded in JSON as `[\"Foo\":\"bar\"]`.  For example, buildargs={\"Foo\":\"bar\"}.  Note(s): * This should not be used to pass secrets. * The value of buildargs should be URI component encoded before being passed to the API.  (As of version 1.xx) 
    - `:shmsize` (integer()): ShmSize is the \"size\" value to use when mounting an shmfs on the container's /dev/shm directory. Default is 64MB (As of version 1.xx) 
    - `:squash` (boolean()): Silently ignored. Squash the resulting images layers into a single layer (As of version 1.xx) 
    - `:labels` (String.t): JSON map of key, value pairs to set as labels on the new image (As of version 1.xx) 
    - `:layers` (boolean()): Cache intermediate layers during build. (As of version 1.xx) 
    - `:networkmode` (String.t): Sets the networking mode for the run commands during build. Supported standard values are:   * `bridge` limited to containers within a single host, port mapping required for external access   * `host` no isolation between host and containers on this network   * `none` disable all networking for this container   * container:<nameOrID> share networking with given container   ---All other values are assumed to be a custom network's name (As of version 1.xx) 
    - `:platform` (String.t): Platform format os[/arch[/variant]] (As of version 1.xx) 
    - `:target` (String.t): Target build stage (As of version 1.xx) 
    - `:outputs` (String.t): output configuration TBD (As of version 1.xx) 
    - `:httpproxy` (boolean()): Inject http proxy environment variables into container (As of version 2.0.0) 
    - `:unsetenv` ([String.t]): Unset environment variables from the final image.

  ### Returns

  - `{:ok, ProvidesAnAPIForTheLibpodLibrary.Model.ImageBuildLibpod200Response.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_build_libpod(Tesla.Env.client(), keyword()) ::
          {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.ImageBuildLibpod200Response.t()}
          | {:error, Tesla.Env.t()}
  def image_build_libpod(connection, opts \\ []) do
    optional_params = %{
      :dockerfile => :query,
      :t => :query,
      :allplatforms => :query,
      :extrahosts => :query,
      :remote => :query,
      :q => :query,
      :nocache => :query,
      :cachefrom => :query,
      :pull => :query,
      :rm => :query,
      :forcerm => :query,
      :memory => :query,
      :memswap => :query,
      :cpushares => :query,
      :cpusetcpus => :query,
      :cpuperiod => :query,
      :cpuquota => :query,
      :buildargs => :query,
      :shmsize => :query,
      :squash => :query,
      :labels => :query,
      :layers => :query,
      :networkmode => :query,
      :platform => :query,
      :target => :query,
      :outputs => :query,
      :httpproxy => :query,
      :unsetenv => :query
    }

    request =
      %{}
      |> method(:post)
      |> url("/libpod/build")
      |> add_optional_params(optional_params, opts)
      |> ensure_body()
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, ProvidesAnAPIForTheLibpodLibrary.Model.ImageBuildLibpod200Response},
      {400, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end

  @doc """
  Report on changes to images's filesystem; adds, deletes or modifications.
  Returns which files in a images's filesystem have been added, deleted, or modified. The Kind of modification can be one of:  0: Modified 1: Added 2: Deleted 

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `name` (String.t): the name or id of the image
  - `opts` (keyword): Optional parameters
    - `:parent` (String.t): specify a second layer which is used to compare against it instead of the parent layer
    - `:diffType` (String.t): select what you want to match, default is all

  ### Returns

  - `{:ok, nil}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_changes_libpod(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, nil}
          | {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:error, Tesla.Env.t()}
  def image_changes_libpod(connection, name, opts \\ []) do
    optional_params = %{
      :parent => :query,
      :diffType => :query
    }

    request =
      %{}
      |> method(:get)
      |> url("/libpod/images/#{name}/changes")
      |> add_optional_params(optional_params, opts)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, false},
      {404, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end

  @doc """
  Remove one or more images from the storage.
  Remove one or more images from the storage.

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `opts` (keyword): Optional parameters
    - `:images` ([String.t]): Images IDs or names to remove.
    - `:all` (boolean()): Remove all images.
    - `:force` (boolean()): Force image removal (including containers using the images).

  ### Returns

  - `{:ok, ProvidesAnAPIForTheLibpodLibrary.Model.LibpodImagesRemoveReport.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_delete_all_libpod(Tesla.Env.client(), keyword()) ::
          {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.LibpodImagesRemoveReport.t()}
          | {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:error, Tesla.Env.t()}
  def image_delete_all_libpod(connection, opts \\ []) do
    optional_params = %{
      :images => :query,
      :all => :query,
      :force => :query
    }

    request =
      %{}
      |> method(:delete)
      |> url("/libpod/images/remove")
      |> add_optional_params(optional_params, opts)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, ProvidesAnAPIForTheLibpodLibrary.Model.LibpodImagesRemoveReport},
      {400, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end

  @doc """
  Remove an image from the local storage.
  Remove an image from the local storage.

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `name` (String.t): name or ID of image to remove
  - `opts` (keyword): Optional parameters
    - `:force` (boolean()): remove the image even if used by containers or has other tags

  ### Returns

  - `{:ok, ProvidesAnAPIForTheLibpodLibrary.Model.LibpodImagesRemoveReport.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_delete_libpod(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.LibpodImagesRemoveReport.t()}
          | {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:error, Tesla.Env.t()}
  def image_delete_libpod(connection, name, opts \\ []) do
    optional_params = %{
      :force => :query
    }

    request =
      %{}
      |> method(:delete)
      |> url("/libpod/images/#{name}")
      |> add_optional_params(optional_params, opts)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, ProvidesAnAPIForTheLibpodLibrary.Model.LibpodImagesRemoveReport},
      {400, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {404, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {409, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end

  @doc """
  Image exists
  Check if image exists in local store

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `name` (String.t): the name or ID of the container
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, nil}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_exists_libpod(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, nil}
          | {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:error, Tesla.Env.t()}
  def image_exists_libpod(connection, name, _opts \\ []) do
    request =
      %{}
      |> method(:get)
      |> url("/libpod/images/#{name}/exists")
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {204, false},
      {404, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end

  @doc """
  Export multiple images
  Export multiple images into a single object. Only `docker-archive` is currently supported.

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `opts` (keyword): Optional parameters
    - `:format` (String.t): format for exported image (only docker-archive is supported)
    - `:references` ([String.t]): references to images to export
    - `:compress` (boolean()): use compression on image
    - `:ociAcceptUncompressedLayers` (boolean()): accept uncompressed layers when copying OCI images

  ### Returns

  - `{:ok, String.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_export_libpod(Tesla.Env.client(), keyword()) ::
          {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:ok, String.t()}
          | {:error, Tesla.Env.t()}
  def image_export_libpod(connection, opts \\ []) do
    optional_params = %{
      :format => :query,
      :references => :query,
      :compress => :query,
      :ociAcceptUncompressedLayers => :query
    }

    request =
      %{}
      |> method(:get)
      |> url("/libpod/images/export")
      |> add_optional_params(optional_params, opts)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, false},
      {404, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end

  @doc """
  Export an image
  Export an image

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `name` (String.t): the name or ID of the container
  - `opts` (keyword): Optional parameters
    - `:format` (String.t): format for exported image
    - `:compress` (boolean()): use compression on image

  ### Returns

  - `{:ok, String.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_get_libpod(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:ok, String.t()}
          | {:error, Tesla.Env.t()}
  def image_get_libpod(connection, name, opts \\ []) do
    optional_params = %{
      :format => :query,
      :compress => :query
    }

    request =
      %{}
      |> method(:get)
      |> url("/libpod/images/#{name}/get")
      |> add_optional_params(optional_params, opts)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, false},
      {404, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end

  @doc """
  History of an image
  Return parent layers of an image.

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `name` (String.t): the name or ID of the container
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, ProvidesAnAPIForTheLibpodLibrary.Model.ImageHistory200Response.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_history_libpod(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.ImageHistory200Response.t()}
          | {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:error, Tesla.Env.t()}
  def image_history_libpod(connection, name, _opts \\ []) do
    request =
      %{}
      |> method(:get)
      |> url("/libpod/images/#{name}/history")
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, ProvidesAnAPIForTheLibpodLibrary.Model.ImageHistory200Response},
      {404, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end

  @doc """
  Import image
  Import a previously exported tarball as an image.

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `upload` (String.t): tarball for imported image
  - `opts` (keyword): Optional parameters
    - `:"Content-Type"` (String.t): 
    - `:changes` ([String.t]): Apply the following possible instructions to the created image: CMD | ENTRYPOINT | ENV | EXPOSE | LABEL | STOPSIGNAL | USER | VOLUME | WORKDIR.  JSON encoded string
    - `:message` (String.t): Set commit message for imported image
    - `:reference` (String.t): Optional Name[:TAG] for the image
    - `:url` (String.t): Load image from the specified URL

  ### Returns

  - `{:ok, ProvidesAnAPIForTheLibpodLibrary.Model.ImageImportReport.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_import_libpod(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.ImageImportReport.t()}
          | {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:error, Tesla.Env.t()}
  def image_import_libpod(connection, upload, opts \\ []) do
    optional_params = %{
      :"Content-Type" => :headers,
      :changes => :query,
      :message => :query,
      :reference => :query,
      :url => :query
    }

    request =
      %{}
      |> method(:post)
      |> url("/libpod/images/import")
      |> add_param(:body, :body, upload)
      |> add_optional_params(optional_params, opts)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, ProvidesAnAPIForTheLibpodLibrary.Model.ImageImportReport},
      {400, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end

  @doc """
  Inspect an image
  Obtain low-level information about an image

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `name` (String.t): the name or ID of the container
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, ProvidesAnAPIForTheLibpodLibrary.Model.ImageInspectLibpod200Response.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_inspect_libpod(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.ImageInspectLibpod200Response.t()}
          | {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:error, Tesla.Env.t()}
  def image_inspect_libpod(connection, name, _opts \\ []) do
    request =
      %{}
      |> method(:get)
      |> url("/libpod/images/#{name}/json")
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, ProvidesAnAPIForTheLibpodLibrary.Model.ImageInspectLibpod200Response},
      {404, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end

  @doc """
  List Images
  Returns a list of images on the server

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `opts` (keyword): Optional parameters
    - `:all` (boolean()): Show all images. Only images from a final layer (no children) are shown by default.
    - `:filters` (String.t): A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters: - `before`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`) - `dangling=true` - `label=key` or `label=\"key=value\"` of an image label - `reference`=(`<image-name>[:<tag>]`) - `id`=(`<image-id>`) - `since`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`) 

  ### Returns

  - `{:ok, [%LibpodImageSummary{}, ...]}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_list_libpod(Tesla.Env.client(), keyword()) ::
          {:ok, [ProvidesAnAPIForTheLibpodLibrary.Model.LibpodImageSummary.t()]}
          | {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:error, Tesla.Env.t()}
  def image_list_libpod(connection, opts \\ []) do
    optional_params = %{
      :all => :query,
      :filters => :query
    }

    request =
      %{}
      |> method(:get)
      |> url("/libpod/images/json")
      |> add_optional_params(optional_params, opts)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, ProvidesAnAPIForTheLibpodLibrary.Model.LibpodImageSummary},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end

  @doc """
  Load image
  Load an image (oci-archive or docker-archive) stream.

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `upload` (String.t): tarball of container image
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, ProvidesAnAPIForTheLibpodLibrary.Model.ImageLoadReport.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_load_libpod(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.ImageLoadReport.t()}
          | {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:error, Tesla.Env.t()}
  def image_load_libpod(connection, upload, _opts \\ []) do
    request =
      %{}
      |> method(:post)
      |> url("/libpod/images/load")
      |> add_param(:body, :body, upload)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, ProvidesAnAPIForTheLibpodLibrary.Model.ImageLoadReport},
      {400, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end

  @doc """
  Prune unused images
  Remove images that are not being used by a container

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `opts` (keyword): Optional parameters
    - `:all` (boolean()): Remove all images not in use by containers, not just dangling ones 
    - `:external` (boolean()): Remove images even when they are used by external containers (e.g, by build containers) 
    - `:filters` (String.t): filters to apply to image pruning, encoded as JSON (map[string][]string). Available filters:   - `dangling=<boolean>` When set to `true` (or `1`), prune only      unused *and* untagged images. When set to `false`      (or `0`), all unused images are pruned.   - `until=<string>` Prune images created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.   - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune images with (or without, in case `label!=...` is used) the specified labels. 

  ### Returns

  - `{:ok, [%LibpodContainersPruneReport{}, ...]}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_prune_libpod(Tesla.Env.client(), keyword()) ::
          {:ok, [ProvidesAnAPIForTheLibpodLibrary.Model.LibpodContainersPruneReport.t()]}
          | {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:error, Tesla.Env.t()}
  def image_prune_libpod(connection, opts \\ []) do
    optional_params = %{
      :all => :query,
      :external => :query,
      :filters => :query
    }

    request =
      %{}
      |> method(:post)
      |> url("/libpod/images/prune")
      |> add_optional_params(optional_params, opts)
      |> ensure_body()
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, ProvidesAnAPIForTheLibpodLibrary.Model.LibpodContainersPruneReport},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end

  @doc """
  Pull images
  Pull one or more images from a container registry.
  Returns a stream of updates as the image is being pulled.

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `opts` (keyword): Optional parameters
    - `:reference` (String.t): Mandatory reference to the image (e.g., quay.io/image/name:tag)
    - `:quiet` (boolean()): silences extra stream data on pull
    - `:credentials` (String.t): username:password for the registry
    - `:Arch` (String.t): Pull image for the specified architecture.
    - `:OS` (String.t): Pull image for the specified operating system.
    - `:Variant` (String.t): Pull image for the specified variant.
    - `:policy` (String.t): Pull policy, \"always\" (default), \"missing\", \"newer\", \"never\".
    - `:tlsVerify` (boolean()): Require TLS verification.
    - `:allTags` (boolean()): Pull all tagged images in the repository.
    - `:"X-Registry-Auth"` (String.t): base-64 encoded auth config. Must include the following four values: username, password, email and server address OR simply just an identity token.

  ### Returns

  - `{:ok, stream}` on success, where stream yields `{:ok, LibpodImagesPullReport.t}` or `{:error, term}` for each line
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_pull_libpod(Tesla.Env.client(), keyword()) ::
          {:ok, Enumerable.t()}
          | {:error, Tesla.Env.t()}
  def image_pull_libpod(connection, opts \\ []) do
    optional_params = %{
      :reference => :query,
      :quiet => :query,
      :credentials => :query,
      :Arch => :query,
      :OS => :query,
      :Variant => :query,
      :policy => :query,
      :tlsVerify => :query,
      :allTags => :query,
      :"X-Registry-Auth" => :headers
    }

    request =
      %{}
      |> method(:post)
      |> url("/libpod/images/pull")
      |> add_optional_params(optional_params, opts)
      |> ensure_body()
      |> Enum.into([])

    # Add adapter option to stream the response body for live updates
    request_with_streaming = request ++ [opts: [adapter: [body_as: :stream]]]

    case Connection.request(connection, request_with_streaming) do
      {:ok, %Tesla.Env{status: status, body: body}} when status >= 200 and status < 300 ->
        stream =
          body
          |> stream_lines()
          |> Stream.map(fn line ->
            case JSON.decode(line) do
              {:ok, decoded} ->
                {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.LibpodImagesPullReport.decode(decoded)}

              {:error, reason} ->
                {:error, {:json_decode_error, reason, line}}
            end
          end)

        {:ok, stream}

      {:ok, %Tesla.Env{status: status} = env} when status >= 400 ->
        {:error, env}

      {:error, _} = error ->
        error
    end
  end

  # Helper function to convert a stream of chunks into a stream of lines
  defp stream_lines(body) when is_binary(body) do
    # If body is already a binary (non-streaming adapter), split by newlines
    body |> String.split("\n", trim: true)
  end

  defp stream_lines(body) do
    # For streaming adapters, body is an enumerable of chunks
    # We need to accumulate partial lines across chunks
    Stream.transform(
      body,
      "",
      fn
        {:ok, chunk}, buffer ->
          process_chunk(buffer <> chunk)

        chunk, buffer when is_binary(chunk) ->
          process_chunk(buffer <> chunk)

        {:error, _} = error, _buffer ->
          {[error], ""}
      end,
      fn
        "" -> {[], ""}
        buffer -> {[buffer], ""}
      end
    )
  end

  defp process_chunk(data) do
    case String.split(data, "\n") do
      [partial] ->
        # No complete line yet, keep accumulating
        {[], partial}

      lines ->
        # Last element might be partial (if data didn't end with \n)
        {complete_lines, [rest]} = Enum.split(lines, -1)
        {Enum.reject(complete_lines, &(&1 == "")), rest}
    end
  end

  @doc """
  Push Image
  Push an image to a container registry

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `name` (String.t): Name of image to push.
  - `opts` (keyword): Optional parameters
    - `:destination` (String.t): Allows for pushing the image to a different destination than the image refers to.
    - `:tlsVerify` (boolean()): Require TLS verification.
    - `:"X-Registry-Auth"` (String.t): A base64-encoded auth configuration.

  ### Returns

  - `{:ok, String.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_push_libpod(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:ok, String.t()}
          | {:error, Tesla.Env.t()}
  def image_push_libpod(connection, name, opts \\ []) do
    optional_params = %{
      :destination => :query,
      :tlsVerify => :query,
      :"X-Registry-Auth" => :headers
    }

    request =
      %{}
      |> method(:post)
      |> url("/libpod/images/#{name}/push")
      |> add_optional_params(optional_params, opts)
      |> ensure_body()
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, false},
      {404, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end

  @doc """
  Search images
  Search registries for images

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `opts` (keyword): Optional parameters
    - `:term` (String.t): term to search
    - `:limit` (integer()): maximum number of results
    - `:filters` (String.t): A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters: - `is-automated=(true|false)` - `is-official=(true|false)` - `stars=<number>` Matches images that has at least 'number' stars. 
    - `:tlsVerify` (boolean()): skip TLS verification for registries
    - `:listTags` (boolean()): list the available tags in the repository

  ### Returns

  - `{:ok, ProvidesAnAPIForTheLibpodLibrary.Model.ImageSearch200Response.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_search_libpod(Tesla.Env.client(), keyword()) ::
          {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.ImageSearch200Response.t()}
          | {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:error, Tesla.Env.t()}
  def image_search_libpod(connection, opts \\ []) do
    optional_params = %{
      :term => :query,
      :limit => :query,
      :filters => :query,
      :tlsVerify => :query,
      :listTags => :query
    }

    request =
      %{}
      |> method(:get)
      |> url("/libpod/images/search")
      |> add_optional_params(optional_params, opts)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, ProvidesAnAPIForTheLibpodLibrary.Model.ImageSearch200Response},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end

  @doc """
  Tag an image
  Tag an image so that it becomes part of a repository.

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `name` (String.t): the name or ID of the container
  - `opts` (keyword): Optional parameters
    - `:repo` (String.t): the repository to tag in
    - `:tag` (String.t): the name of the new tag

  ### Returns

  - `{:ok, nil}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_tag_libpod(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, nil}
          | {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:error, Tesla.Env.t()}
  def image_tag_libpod(connection, name, opts \\ []) do
    optional_params = %{
      :repo => :query,
      :tag => :query
    }

    request =
      %{}
      |> method(:post)
      |> url("/libpod/images/#{name}/tag")
      |> add_optional_params(optional_params, opts)
      |> ensure_body()
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {201, false},
      {400, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {404, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {409, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end

  @doc """
  Image tree
  Retrieve the image tree for the provided image name or ID

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `name` (String.t): the name or ID of the container
  - `opts` (keyword): Optional parameters
    - `:whatrequires` (boolean()): show all child images and layers of the specified image

  ### Returns

  - `{:ok, ProvidesAnAPIForTheLibpodLibrary.Model.ImageTreeLibpod200Response.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_tree_libpod(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.ImageTreeLibpod200Response.t()}
          | {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:error, Tesla.Env.t()}
  def image_tree_libpod(connection, name, opts \\ []) do
    optional_params = %{
      :whatrequires => :query
    }

    request =
      %{}
      |> method(:get)
      |> url("/libpod/images/#{name}/tree")
      |> add_optional_params(optional_params, opts)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, ProvidesAnAPIForTheLibpodLibrary.Model.ImageTreeLibpod200Response},
      {404, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end

  @doc """
  Untag an image
  Untag an image. If not repo and tag are specified, all tags are removed from the image.

  ### Parameters

  - `connection` (ProvidesAnAPIForTheLibpodLibrary.Connection): Connection to server
  - `name` (String.t): the name or ID of the container
  - `opts` (keyword): Optional parameters
    - `:repo` (String.t): the repository to untag
    - `:tag` (String.t): the name of the tag to untag

  ### Returns

  - `{:ok, nil}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec image_untag_libpod(Tesla.Env.client(), String.t(), keyword()) ::
          {:ok, nil}
          | {:ok, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response.t()}
          | {:error, Tesla.Env.t()}
  def image_untag_libpod(connection, name, opts \\ []) do
    optional_params = %{
      :repo => :query,
      :tag => :query
    }

    request =
      %{}
      |> method(:post)
      |> url("/libpod/images/#{name}/untag")
      |> add_optional_params(optional_params, opts)
      |> ensure_body()
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {201, false},
      {400, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {404, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {409, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response},
      {500, ProvidesAnAPIForTheLibpodLibrary.Model.SystemAuth500Response}
    ])
  end
end
